console.log('Background script running.');

/**
 * íƒ€ì…ë³„(3ì‹œê°„/ì¼ê°„/ì£¼ê°„/ì›”ê°„) ì¹´ìš´íŠ¸ ê³„ì‚°
 * @param {Array} timestamps - íƒ€ì„ìŠ¤íƒ¬í”„ ë°°ì—´
 * @param {string} type - "threeHour", "daily", "weekly", "monthly" ì¤‘ í•˜ë‚˜
 * @returns {number} í•´ë‹¹ ê¸°ê°„ ë‚´ ì¹´ìš´íŠ¸
 */
function getCountByType(timestamps, type) {
  if (!timestamps || !Array.isArray(timestamps)) return 0;
  
  const now = Date.now();
  let cutoffTime;
  
  switch (type) {
    case 'threeHour':
      cutoffTime = now - (3 * 60 * 60 * 1000); // 3ì‹œê°„
      break;
    case 'daily':
      // ë‹¹ì¼ 00:00 KST ê¸°ì¤€
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      cutoffTime = today.getTime();
      break;
    case 'weekly':
      // ì´ë²ˆ ì£¼ ì›”ìš”ì¼ 00:00 KST ê¸°ì¤€
      const thisMonday = new Date();
      thisMonday.setHours(0, 0, 0, 0);
      // ì›”ìš”ì¼ì´ 0ì´ ì•„ë‹ˆë¼ 1ì´ë¯€ë¡œ ì¼ìš”ì¼ì€ 0, ì›”ìš”ì¼ì€ 1...
      const daysSinceMonday = (thisMonday.getDay() + 6) % 7; // ì›”ìš”ì¼ì„ ê¸°ì¤€ìœ¼ë¡œ ë‚ ì§œ ì¡°ì •
      thisMonday.setDate(thisMonday.getDate() - daysSinceMonday);
      cutoffTime = thisMonday.getTime();
      break;
    case 'monthly':
      // ì´ë²ˆ ë‹¬ 1ì¼ 00:00 KST ê¸°ì¤€
      const thisMonth = new Date();
      thisMonth.setDate(1);
      thisMonth.setHours(0, 0, 0, 0);
      cutoffTime = thisMonth.getTime();
      break;
    default:
      cutoffTime = 0;
  }
  
  // í•´ë‹¹ ê¸°ê°„ ì´í›„ì˜ íƒ€ì„ìŠ¤íƒ¬í”„ë§Œ í•„í„°ë§í•´ì„œ ê°œìˆ˜ ë°˜í™˜
  return timestamps.filter(timestamp => timestamp >= cutoffTime).length;
}

// ê³µí†µ: ë‹¤ìŒ ë¦¬ì…‹ ì‹œê° ê³„ì‚° (KST ìì • ê¸°ì¤€)
function getNextResetTimestamp() {
    const now = new Date();
    const kstMidnight = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 15, 0, 0));
    if (now.getTime() >= kstMidnight.getTime()) {
        kstMidnight.setUTCDate(kstMidnight.getUTCDate() + 1);
    }
    return kstMidnight.getTime();
}

// ë”¥ë¦¬ì„œì¹˜ ì „ìš©: ì›”ê°„ ë¦¬ì…‹ ì‹œê° ê³„ì‚° (ë§¤ì›” 1ì¼ KST 00:00)
function getNextMonthlyResetTimestamp() {
    const now = new Date();
    // ë‹¤ìŒ ë‹¬ 1ì¼ ìì •(ë¡œì»¬ ì‹œê°„ KST ê¸°ì¤€)
    const next = new Date(now.getFullYear(), now.getMonth() + 1, 1, 0, 0, 0);
    return next.getTime();
}

// ì„ì‹œ ìš”ì²­/ì‘ë‹µ ë°ì´í„° ì €ì¥ì†Œ (requestId ê¸°ì¤€)
const requestCache = {};

// conversation/init API ìš”ì²­ ê°ì‹œ - ìš”ì²­ ë‹¨ê³„
chrome.webRequest.onBeforeRequest.addListener(
    (details) => {
        // ëª¨ë“  ìš”ì²­ URL ë¡œê¹… (ë””ë²„ê¹…ìš©)
        console.log('ìš”ì²­ ê°ì§€ë¨:', details.url);
        
        // /backend-api/conversation/init ìš”ì²­ ê°ì§€
        if (!details.url || !details.url.includes('/backend-api/conversation')) return;

        console.log('ê°ì§€: conversation/ ìš”ì²­', details.url);

        // ìš”ì²­ IDì™€ URL, ë³¸ë¬¸ ì €ì¥
        requestCache[details.requestId] = { 
            url: details.url,
            timestamp: Date.now()
        };
        
        // ìš”ì²­ ë³¸ë¬¸ì´ ìˆëŠ” ê²½ìš° ì €ì¥
        console.log(details)
        if (details.requestBody && details.requestBody.raw && details.requestBody.raw[0]) {
            requestCache[details.requestId].body = details.requestBody.raw[0].bytes;
            console.log('ìš”ì²­ ë³¸ë¬¸ ì €ì¥ë¨:', details.requestId);
            //í•´ë… ì‹œë„
                const rawBytes = requestCache[details.requestId].body;
                const bodyText = decodeURIComponent(
                    String.fromCharCode.apply(null, new Uint8Array(rawBytes))
                );
                console.log('ìš”ì²­ ë³¸ë¬¸ ë””ì½”ë”©:', bodyText);
        }
    },
    {
        urls: [
            "https://*.openai.com/backend-api/conversation/init*",
            "https://chat.openai.com/backend-api/conversation/init*",
            "https://chatgpt.com/backend-api/conversation"
        ]
    },
    ["requestBody", "extraHeaders"]
);


// ë©”ì‹œì§€ ì¹´ìš´íŠ¸ìš© conversation ìš”ì²­ ê°ì‹œ
// [ë²„ê·¸ ìˆ˜ì •] ì•„ë˜ ë¦¬ìŠ¤ë„ˆëŠ” ì£¼ì„ ì²˜ë¦¬ë¨ (updateModelUsageWithWorkspaceë¡œ ëŒ€ì²´)
// ì´ìœ : ê°™ì€ ìš”ì²­ì— ëŒ€í•´ ë‘ ë²ˆ ì¹´ìš´íŒ…ë˜ëŠ” ë¬¸ì œ í•´ê²°
/*
chrome.webRequest.onBeforeRequest.addListener(
    (details) => {
        if (!details.method || details.method !== 'POST' || !details.requestBody || !details.requestBody.raw) return;
        
        try {
            // ìš”ì²­ ë³¸ë¬¸ íŒŒì‹±
            const rawBytes = details.requestBody.raw[0].bytes;
            const bodyText = decodeURIComponent(
                String.fromCharCode.apply(null, new Uint8Array(rawBytes))
            );
            const body = JSON.parse(bodyText);
            
            if (body && body.model) {
                const modelName = body.model;
                console.log('ëŒ€í™” ìš”ì²­ ê°ì§€, ëª¨ë¸:', modelName);
                
                // ëª¨ë¸ë³„ ì‚¬ìš©ëŸ‰ ì¹´ìš´íŒ… í•¨ìˆ˜ í˜¸ì¶œ
                updateModelUsage(modelName);
            }
        } catch (e) {
            console.warn('ëŒ€í™” ìš”ì²­ ë³¸ë¬¸ íŒŒì‹± ì‹¤íŒ¨:', e);
        }
    },
    {
        urls: [
            "https://*.openai.com/backend-api/conversation*",
            "https://chatgpt.com/backend-api/conversation*"
        ]
    },
    ["requestBody"]
);
*/

// ëª¨ë¸ë³„ ì‚¬ìš©ëŸ‰ ì¹´ìš´íŠ¸ ì¦ê°€ í•¨ìˆ˜
function updateModelUsage(modelName) {
    if (!modelName) return;
    
    // storageì—ì„œ í˜„ì¬ ë°ì´í„° ë¡œë“œ
    chrome.storage.local.get(['usageCounts', 'limits'], data => {
        const usageCounts = data.usageCounts || {};
        const limits = data.limits || {};
        
        // í•´ë‹¹ ëª¨ë¸ì˜ ì¹´ìš´íŠ¸ ê°ì²´ ê°€ì ¸ì˜¤ê±°ë‚˜ ì´ˆê¸°í™”
        const modelUsage = usageCounts[modelName] || { daily: 0, monthly: 0, threeHour: 0 };
        
        // í˜„ì¬ ì‹œê°„ê³¼ ë‚ ì§œ/ì›” ì •ë³´
        const now = new Date();
        const today = now.toISOString().split('T')[0]; // YYYY-MM-DD
        const month = today.substring(0, 7); // YYYY-MM
        const threeHoursAgo = now.getTime() - (3 * 60 * 60 * 1000);
        
        // ë§ˆì§€ë§‰ ë¦¬ì…‹ ì‹œê°„ í™•ì¸ (ì—†ìœ¼ë©´ ì´ˆê¸°í™”)
        if (!usageCounts._lastReset) {
            usageCounts._lastReset = {
                daily: today,
                monthly: month,
                threeHour: now.getTime()
            };
        }
        
        // ì¼ë³„ ë¦¬ì…‹ í™•ì¸
        if (usageCounts._lastReset.daily !== today) {
            // ëª¨ë“  ëª¨ë¸ì˜ ì¼ë³„ ì¹´ìš´íŠ¸ ì´ˆê¸°í™”
            Object.keys(usageCounts).forEach(model => {
                if (model !== '_lastReset' && usageCounts[model]) {
                    usageCounts[model].daily = 0;
                }
            });
            usageCounts._lastReset.daily = today;
        }
        
        // ì›”ë³„ ë¦¬ì…‹ í™•ì¸
        if (usageCounts._lastReset.monthly !== month) {
            // ëª¨ë“  ëª¨ë¸ì˜ ì›”ë³„ ì¹´ìš´íŠ¸ ì´ˆê¸°í™”
            Object.keys(usageCounts).forEach(model => {
                if (model !== '_lastReset' && usageCounts[model]) {
                    usageCounts[model].monthly = 0;
                }
            });
            usageCounts._lastReset.monthly = month;
        }
        
        // 3ì‹œê°„ ë¦¬ì…‹ í™•ì¸ (GPT-4 ë“±ì—ì„œ ì‚¬ìš©)
        // threeHourëŠ” íƒ€ì„ìŠ¤íƒ¬í”„ ë°°ì—´ë¡œ ê´€ë¦¬í•˜ì—¬ ë¡¤ë§ ìœˆë„ìš° ë°©ì‹ìœ¼ë¡œ ê³„ì‚°
        if (!modelUsage.threeHourTimestamps) {
            modelUsage.threeHourTimestamps = [];
        }
        
        // ìƒˆ ìš”ì²­ ì‹œê°„ ì¶”ê°€
        modelUsage.threeHourTimestamps.push(now.getTime());
        
        // 3ì‹œê°„ ì´ì „ ìš”ì²­ë“¤ ì œê±°
        modelUsage.threeHourTimestamps = modelUsage.threeHourTimestamps.filter(
            timestamp => timestamp > threeHoursAgo
        );
        
        // í˜„ì¬ 3ì‹œê°„ ë‚´ ìš”ì²­ ìˆ˜
        modelUsage.threeHour = modelUsage.threeHourTimestamps.length;
        
        // ì¼ë³„/ì›”ë³„ ì¹´ìš´í„° ì¦ê°€
        modelUsage.daily++;
        modelUsage.monthly++;
        
        // ì—…ë°ì´íŠ¸ëœ ì‚¬ìš©ëŸ‰ ì €ì¥
        usageCounts[modelName] = modelUsage;
        
        // í˜„ì¬ í•œë„ ìƒíƒœ ì ê²€
        const modelLimit = limits[modelName];
        if (modelLimit) {
            const limitType = modelLimit.type; // 'daily', 'monthly', 'threeHour'
            const limitValue = modelLimit.value;
            const currentUsage = modelUsage[limitType] || 0;
            
            // í•œë„ ì„ë°• (90% ì´ìƒ ì‚¬ìš©) ì²´í¬
            if (limitValue && currentUsage >= limitValue * 0.9) {
                // ë¸Œë¼ìš°ì € ì•Œë¦¼ í‘œì‹œ
                chrome.notifications.create({
                    type: 'basic',
                    iconUrl: 'icon-128.png', // ì•„ì´ì½˜ì´ ìˆì–´ì•¼ í•¨
                    title: `${modelName} ì‚¬ìš©ëŸ‰ ê²½ê³ `,
                    message: `í˜„ì¬ ${currentUsage}/${limitValue} (${Math.round(currentUsage/limitValue*100)}%) ì‚¬ìš©í•˜ì˜€ìŠµë‹ˆë‹¤.`,
                    priority: 1
                });
            }
        }
        
        // storageì— ì €ì¥
        chrome.storage.local.set({ usageCounts });
        console.log(`ëª¨ë¸ ${modelName} ì‚¬ìš©ëŸ‰ ì—…ë°ì´íŠ¸:`, modelUsage);
    });
}

// Deep Research API ì‘ë‹µ ëª¨ë‹ˆí„°ë§ì„ ìœ„í•œ webRequest ë¦¬ìŠ¤ë„ˆ
chrome.webRequest.onResponseStarted.addListener(
    (details) => {
        // URLì´ ì¡´ì¬í•˜ëŠ”ì§€ ë¨¼ì € í™•ì¸
        if (!details.url) {
            return;
        }
        
    // ê¸°ì¡´ í—¤ë” ë°©ì‹ë„ ìœ ì§€ (ë‹¤ë¥¸ APIì—ì„œ ì •ë³´ê°€ ìˆì„ ìˆ˜ ìˆìŒ)
    },
    {
        urls: [
            "https://chat.openai.com/backend-api/*",
            "https://chatgpt.com/backend-api/*",
            "https://chat.openai.com/*deep*",
            "https://chat.openai.com/*research*",
            "https://chatgpt.com/*deep*",
            "https://chatgpt.com/*research*"
        ]
    },
    ["responseHeaders"]
);


// ê¸°ë³¸ ëª¨ë¸ë³„ í•œë„ (ì˜ˆì‹œ)
// í”Œëœë³„ ëª¨ë¸ í•œë„ ì„¤ì •
const defaultLimits = {
    free: {
        "gpt-4-1-mini": { type: "unlimited", value: null },
        "gpt-4o": { type: "daily", value: 10 }, // ì œí•œì ì´ë¯€ë¡œ ì¶”ì •ê°’
        "o4-mini": { type: "daily", value: 10 }, // ì œí•œì ì´ë¯€ë¡œ ì¶”ì •ê°’
        "deep-research": { type: "monthly", value: 5 }
    },
    plus: {
        "gpt-4-1-mini": { type: "unlimited", value: null },
        "gpt-4o": { type: "threeHour", value: 80 },
        "gpt-4-1": { type: "threeHour", value: 80 },
        "gpt-4-5": { type: "weekly", value: 50 },
        "o3": { type: "weekly", value: 100 },
        "o4-mini": { type: "daily", value: 300 },
        "o4-mini-high": { type: "daily", value: 100 },
        "deep-research": { type: "monthly", value: 25 }
    },
    pro: {
        "gpt-4-1-mini": { type: "unlimited", value: null },
        "gpt-4o": { type: "unlimited", value: null },
        "gpt-4-1": { type: "unlimited", value: null },
        "gpt-4-5": { type: "unlimited", value: null },
        "o3": { type: "unlimited", value: null },
        "o4-mini": { type: "unlimited", value: null },
        "o4-mini-high": { type: "unlimited", value: null },
        "o1-pro": { type: "unlimited", value: null },
        "deep-research": { type: "monthly", value: 250 }
    }
};

// í˜„ì¬ ì‚¬ìš©ì í”Œëœ (ì´ˆê¸°ê°’: free, ë‚˜ì¤‘ì— ì„¤ì • UIì—ì„œ ë³€ê²½ ê°€ëŠ¥)
let currentPlan = "free";

// storage ì´ˆê¸°í™”
chrome.runtime.onInstalled.addListener(() => {
    const initialDr = {
        remaining: '-',
        total: defaultLimits[currentPlan]['deep-research']?.value || '-',
        resetAt: getNextMonthlyResetTimestamp()
    };
    chrome.storage.local.set({ 
        usageCounts: {}, 
        limits: defaultLimits[currentPlan],
        currentPlan: currentPlan,
        deepResearch: initialDr
    });
    scheduleResets();
});

// ë¦¬ì…‹ ì•ŒëŒë“¤ ë“±ë¡
function scheduleResets() {
    // ë§¤ì¼ ìì • KST ê¸°ì¤€ ë¦¬ì…‹
    const now = new Date();
    const kstMidnight = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 15, 0, 0));
    if (now.getTime() >= kstMidnight.getTime()) {
        kstMidnight.setUTCDate(kstMidnight.getUTCDate() + 1);
    }
    chrome.alarms.create('dailyReset', { when: kstMidnight.getTime(), periodInMinutes: 24 * 60 });
    
    // 3ì‹œê°„ë§ˆë‹¤ ë¦¬ì…‹ (í˜„ì¬ ì‹œê°ë¶€í„° 3ì‹œê°„ í›„)
    chrome.alarms.create('threeHourReset', { when: Date.now() + (3 * 60 * 60 * 1000), periodInMinutes: 3 * 60 });
    
    // ë§¤ì£¼ ì›”ìš”ì¼ 00:00 KST ë¦¬ì…‹
    const nextMonday = new Date(kstMidnight);
    const daysUntilMonday = (1 + 7 - nextMonday.getDay()) % 7;
    if (daysUntilMonday === 0 && now.getTime() >= kstMidnight.getTime()) {
        nextMonday.setUTCDate(nextMonday.getUTCDate() + 7);
    } else {
        nextMonday.setUTCDate(nextMonday.getUTCDate() + daysUntilMonday);
    }
    chrome.alarms.create('weeklyReset', { when: nextMonday.getTime(), periodInMinutes: 7 * 24 * 60 });
    
    // ë§¤ì›” 1ì¼ 00:00 KST ë¦¬ì…‹
    const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1, 0, 0, 0);
    chrome.alarms.create('monthlyReset', { when: nextMonth.getTime() });
}

chrome.alarms.onAlarm.addListener((alarm) => {
    // ë°°ì—´ ê¸°ë°˜ íƒ€ì„ìŠ¤íƒ¬í”„ ì €ì¥ ì‹œìŠ¤í…œì—ì„œëŠ” ë°ì´í„°ë¥¼ ë¦¬ì…‹í•  í•„ìš”ê°€ ì—†ìŒ
    // ê° ìš”ì²­ì˜ íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ ì €ì¥í•˜ê³  getCountByType í•¨ìˆ˜ì—ì„œ ë™ì ìœ¼ë¡œ ê³„ì‚°
    
    // ë‹¨, ë°ì´í„° ì •ë¦¬ ì•ŒëŒì€ ì²˜ë¦¬
    if (alarm.name === 'cleanupData') {
        cleanupOldData();
    }
    
    // ë°°ì§€ ì—…ë°ì´íŠ¸ (íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë°˜ìœ¼ë¡œ ê³„ì‚°)
    chrome.storage.local.get('usageCounts', data => {
        updateBadge(data.usageCounts || {});
    });
    
    // ì›”ê°„ ë¦¬ì…‹ ì•ŒëŒ ì¬ì„¤ì • (ëª¨ë¸ë³„ íƒ€ì„ìŠ¤íƒ¬í”„ ë°°ì—´ì— ê¸°ë°˜í•˜ì—¬ ì¹´ìš´íŠ¸í•˜ë¯€ë¡œ ì§ì ‘ì ì¸ ë¦¬ì…‹ì€ í•„ìš”ì—†ìŒ)
    if (alarm.name === 'monthlyReset') {
        const now = new Date();
        const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1, 0, 0, 0);
        chrome.alarms.create('monthlyReset', { when: nextMonth.getTime() });
    }
});

// ë©”ì‹œì§€ ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    // 1. Request/fetch Hookì—ì„œ ìº¡ì²˜í•œ conversation/init ìš”ì²­ ì²˜ë¦¬
    if (message.type === 'init_request_captured' && message.data) {
        console.log('ğŸ“¨ Content scriptë¡œë¶€í„° conversation/init ë°ì´í„° ìˆ˜ì‹ :', message.data);
        
        try {
            const { url, body } = message.data;
            
            // Deep Research ì •ë³´ ì¶”ì¶œ ë° ì €ì¥
            if (body && body.limits_progress) {
                const deepResearchLimit = body.limits_progress.find(
                    limit => limit.feature_name === 'deep_research'
                );
                
                if (deepResearchLimit) {
                    const remaining = deepResearchLimit.remaining;
                    const resetTime = deepResearchLimit.reset_after;

                    console.log('ğŸ’¡ Deep Research ì •ë³´ ì¶”ì¶œ ì„±ê³µ:', { remaining, resetTime });

                    // storage ì—…ë°ì´íŠ¸
                    chrome.storage.local.get(['deepResearch', 'currentPlan'], data => {
                        const dr = data.deepResearch || {};
                        const plan = data.currentPlan || currentPlan;

                        dr.remaining = remaining;
                        // reset_afterê°€ ISO8601 ë¬¸ìì—´("2025-06-20T05:20:09.983812+00:00")ì¼ ë•Œë„ ì •ìƒ ì²˜ë¦¬
                        dr.resetAt = new Date(resetTime).getTime();

                        const def = defaultLimits[plan] && defaultLimits[plan]['deep-research'];
                        dr.total = def && def.value != null ? def.value : dr.total || '?';

                        chrome.storage.local.set({ deepResearch: dr });
                        console.log('ğŸ’¾ Deep Research ì •ë³´ ì €ì¥ ì™„ë£Œ:', dr);
                    });
                }
            }
        } catch (error) {
            console.error('âŒ conversation/init ë°ì´í„° ì²˜ë¦¬ ì‹¤íŒ¨:', error);
        }
    }
    
    // 2. Fetch Hookì—ì„œ ìº¡ì²˜í•œ Deep Research ì •ë³´ ì§ì ‘ ì²˜ë¦¬
    if (message.type === 'deep_research_info' && message.info) {
        console.log('ğŸ” Content scriptë¡œë¶€í„° Deep Research ì •ë³´ ìˆ˜ì‹ :', message.info);
        
        try {
            const { remaining, reset_after } = message.info;
            
            // storage ì—…ë°ì´íŠ¸
            chrome.storage.local.get(['deepResearch', 'currentPlan'], data => {
                const dr = data.deepResearch || {};
                const plan = data.currentPlan || currentPlan;
                
                dr.remaining = remaining;
                dr.resetAt = new Date(reset_after).getTime();
                
                const def = defaultLimits[plan] && defaultLimits[plan]['deep-research'];
                dr.total = def && def.value != null ? def.value : dr.total || '?';
                
                chrome.storage.local.set({ deepResearch: dr });
                console.log('ğŸ’¾ Deep Research ì •ë³´ ì €ì¥ ì™„ë£Œ (fetch hook):', dr);
                
                // ë°°ì§€ ì—…ë°ì´íŠ¸ (ì„ íƒì )
                if (remaining <= 10) {  // ì ì€ íšŸìˆ˜ì¼ ê²½ìš° ë°°ì§€ì— í‘œì‹œ
                    chrome.action.setBadgeText({ text: `DR:${remaining}` });
                    chrome.action.setBadgeBackgroundColor({ color: remaining <= 5 ? '#FF0000' : '#FFA500' });
                }
            });
        } catch (error) {
            console.error('âŒ Deep Research ì •ë³´ ì²˜ë¦¬ ì‹¤íŒ¨:', error);
        }
    }
      if (message.type === 'messageCount' && message.model) {
        console.log('ğŸ“¨ Content scriptë¡œë¶€í„° ë©”ì‹œì§€ ì¹´ìš´íŠ¸ ìˆ˜ì‹ :', message.model);
        chrome.storage.local.get(['usageCounts', 'limits', 'currentPlan'], data => {
            const counts = data.usageCounts || {};
            const limits = data.limits || defaultLimits[data.currentPlan || 'free'];
            const model = message.model;
            
            // íƒ€ì„ìŠ¤íƒ¬í”„ ë°°ì—´ ê¸°ë°˜ ì €ì¥ì†Œ
            if (!counts[model]) {
                counts[model] = { timestamps: [] };
            }
            
            if (!counts[model].timestamps) {
                counts[model].timestamps = [];
            }
            
            // í˜„ì¬ íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ê°€
            const now = Date.now();
            counts[model].timestamps.push(now);
            
            // ëª¨ë¸ì˜ ì œí•œ íƒ€ì…ì— ë”°ë¼ í•´ë‹¹ ì¹´ìš´í„° í™•ì¸
            if (limits[model]) {
                const limitType = limits[model].type;
                const limitValue = limits[model].value;
                
                // unlimitedê°€ ì•„ë‹Œ ê²½ìš°ì—ë§Œ í•œë„ í™•ì¸
                if (limitType !== 'unlimited') {
                    chrome.storage.local.set({ usageCounts: counts }, () => {
                        updateBadge(counts);
                        
                        // íƒ€ì„ìŠ¤íƒ¬í”„ ë°°ì—´ ê¸°ë°˜ìœ¼ë¡œ í˜„ì¬ ì¹´ìš´íŠ¸ ê³„ì‚°
                        const currentCount = getCountByType(counts[model].timestamps, limitType);
                        
                        // í•œë„ ì„ë°• ì•Œë¦¼ (80% ë„ë‹¬ ì‹œ)
                        if (limitValue && currentCount >= limitValue * 0.8) {
                            chrome.notifications.create({
                                type: 'basic',
                                iconUrl: 'icons/icon48.png',
                                title: 'ì‚¬ìš©ëŸ‰ ê²½ê³ ',
                                message: `${model} ìš”ì²­ì´ ${limitType === 'threeHour' ? '3ì‹œê°„' : limitType === 'daily' ? 'ì¼ì¼' : limitType === 'weekly' ? 'ì£¼ê°„' : 'ì›”ê°„'} í•œë„ì˜ 80%ì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤. (${currentCount}/${limitValue})`
                            });
                        }
                    });
                }
            }
        });
    }
    
    // Deep Research ë‚¨ì€ íšŸìˆ˜ ì €ì¥
    if (message.type === 'deepResearchRemaining') {
        chrome.storage.local.get(['deepResearch', 'currentPlan'], data => {
            const dr = data.deepResearch || {};
            // ë‚¨ì€ íšŸìˆ˜ ì—…ë°ì´íŠ¸
            dr.remaining = message.remaining;
            // í”Œëœì— ë”°ë¥¸ ì „ì²´ í•œë„ ì„¤ì •
            const plan = data.currentPlan || currentPlan;
            const def = defaultLimits[plan] && defaultLimits[plan]['deep-research'];
            dr.total = (def && def.value != null) ? def.value : dr.total;
            // init API bodyì—ì„œ ì „ë‹¬ëœ resetTime(seconds or ISO) ì²˜ë¦¬
            if (message.resetTime != null) {
                const rt = message.resetTime;
                dr.resetAt = new Date(rt).getTime();
            }
            chrome.storage.local.set({ deepResearch: dr }, () => {
                sendResponse({ status: 'ok' });
            });
        });
        return true;
    }

    // í”Œëœ ë³€ê²½
    if (message.type === 'changePlan' && message.plan) {
        currentPlan = message.plan;
        const newLimits = defaultLimits[currentPlan] || {};
        // deepResearch: ê¸°ì¡´ remaining ê°’ ìœ ì§€í•˜ê³  totalë§Œ ì—…ë°ì´íŠ¸
        chrome.storage.local.get('deepResearch', data => {
            const oldDr = data.deepResearch || {};
            const dr = {
                remaining: oldDr.remaining ?? '-',
                total: newLimits['deep-research']?.value ?? '-',
                resetAt: oldDr.resetAt ?? getNextMonthlyResetTimestamp()
            };
            chrome.storage.local.set({ limits: newLimits, currentPlan, deepResearch: dr }, () => {
                sendResponse({ status: 'ok' });
            });
        });
        return true;
    }

    return true;
});

// 3ë‹¨ê³„ webRequest ì²´ì¸ì„ ìœ„í•œ ì„ì‹œ ì €ì¥ì†Œ
const requestDataStore = {};

// 1ë‹¨ê³„: onBeforeRequest - ìš”ì²­ ë°”ë”” ì €ì¥
chrome.webRequest.onBeforeRequest.addListener(
  (details) => {
    console.log('[Background] onBeforeRequest:', details.url);
    
    // í—ˆìš©ëœ ë„ë©”ì¸ ì²´í¬
    const allowedDomains = ['chat.openai.com', 'chatgpt.com'];
    const initiator = details.initiator || '';
    const isAllowedDomain = allowedDomains.some(domain => initiator.includes(domain));
    
    if (!isAllowedDomain) return;
    
    if (details.requestBody && details.requestBody.raw && details.requestBody.raw[0]) {
      const bodyBytes = details.requestBody.raw[0].bytes;
      requestDataStore[details.requestId] = { 
        body: bodyBytes,
        url: details.url,
        timestamp: Date.now()
      };
      console.log('[Background] ìš”ì²­ ë°”ë”” ì €ì¥ë¨:', details.requestId);
    }
  },
  { 
    urls: [
      "*://chat.openai.com/backend-api/conversation*",
      "*://chatgpt.com/backend-api/conversation*",
      "*://chatgpt.com/backend-alt/conversation*"
    ] 
  },
  ["requestBody"]
);

// 2ë‹¨ê³„: onSendHeaders - ìš”ì²­ í—¤ë” ì €ì¥ (workspace_id ì¶”ì¶œìš©)
chrome.webRequest.onSendHeaders.addListener(
  (details) => {
    console.log('[Background] onSendHeaders:', details.url);
    
    const allowedDomains = ['chat.openai.com', 'chatgpt.com'];
    const initiator = details.initiator || '';
    const isAllowedDomain = allowedDomains.some(domain => initiator.includes(domain));
    
    if (!isAllowedDomain) return;
    
    const storedData = requestDataStore[details.requestId];
    if (storedData) {
      storedData.headers = details.requestHeaders;
      console.log('[Background] ìš”ì²­ í—¤ë” ì €ì¥ë¨:', details.requestId);
    }
  },
  { 
    urls: [
      "*://chat.openai.com/backend-api/conversation*",
      "*://chatgpt.com/backend-api/conversation*",
      "*://chatgpt.com/backend-alt/conversation*"
    ] 
  },
  ["requestHeaders", "extraHeaders"]
);

// 3ë‹¨ê³„: onResponseStarted - ì‘ë‹µ ì‹œì‘ ì‹œ ëª¨ë¸ ì •ë³´ íŒŒì‹±
chrome.webRequest.onResponseStarted.addListener(
  async (details) => {
    console.log('[Background] onResponseStarted (conversation):', details.url);
    
    const allowedDomains = ['chat.openai.com', 'chatgpt.com'];
    const initiator = details.initiator || '';
    const isAllowedDomain = allowedDomains.some(domain => initiator.includes(domain));
    
    if (!isAllowedDomain) return;
    
    const storedData = requestDataStore[details.requestId];
    if (!storedData) return;
    
    // ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€ë¥¼ ìœ„í•´ ì¦‰ì‹œ ì‚­ì œ
    delete requestDataStore[details.requestId];
    
    try {
      // ìš”ì²­ ë°”ë”” ë””ì½”ë”©
      const decoder = new TextDecoder('utf-8');
      const requestBodyText = decoder.decode(new Uint8Array(storedData.body));
      const requestData = JSON.parse(requestBodyText);
      
      console.log('[Background] ìš”ì²­ ë°ì´í„° íŒŒì‹±ë¨:', requestData);
      
      // ëª¨ë¸ ì •ë³´ ì¶”ì¶œ
      let modelName = requestData.model;
      
      // auto ëª¨ë¸ ì²˜ë¦¬ (ì‹¤ì œ ì‚¬ìš©ëœ ëª¨ë¸ë¡œ ë³´ì •)
      if (modelName === 'auto') {
        // ì‹¤ì œ ì‘ë‹µì—ì„œ ì‚¬ìš©ëœ ëª¨ë¸ì„ í™•ì¸í•˜ê±°ë‚˜ ê¸°ë³¸ê°’ ì„¤ì •
        modelName = 'gpt-4o'; // ê¸°ë³¸ê°’
      }
      
      console.log('[Background] ì‚¬ìš©ëœ ëª¨ë¸:', modelName);
      
      // workspace_id ì¶”ì¶œ (ì¿ í‚¤ì—ì„œ)
      let workspaceId = 'default';
      if (storedData.headers) {
        const cookieHeader = storedData.headers.find(h => h.name.toLowerCase() === 'cookie');
        if (cookieHeader) {
          // workspace_id ì¿ í‚¤ íŒŒì‹±
          const workspaceMatch = cookieHeader.value.match(/workspace_id=([^;]+)/);
          if (workspaceMatch) {
            workspaceId = workspaceMatch[1];
          }
        }
      }
      
      console.log('[Background] Workspace ID:', workspaceId);
      
      // ëª¨ë¸ ì‚¬ìš©ëŸ‰ ì—…ë°ì´íŠ¸
      await updateModelUsageWithWorkspace(modelName, workspaceId);
      
    } catch (error) {
      console.error('[Background] ìš”ì²­ ë°ì´í„° íŒŒì‹± ì—ëŸ¬:', error);
    }
  },
  { 
    urls: [
      "*://chat.openai.com/backend-api/conversation*",
      "*://chatgpt.com/backend-api/conversation*",
      "*://chatgpt.com/backend-alt/conversation*"
    ] 
  },
  ["responseHeaders"]
);

// workspaceë³„ ëª¨ë¸ ì‚¬ìš©ëŸ‰ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
async function updateModelUsageWithWorkspace(model, workspaceId) {
  try {
    const data = await chrome.storage.local.get(['usageCounts', 'limits', 'currentPlan']);
    const counts = data.usageCounts || {};
    const limits = data.limits || defaultLimits[data.currentPlan || 'free'];
    
    // workspaceë³„ë¡œ ì¹´ìš´íŠ¸ ê´€ë¦¬ - ìƒˆ ë°°ì—´ ê¸°ë°˜ ì‹œìŠ¤í…œ
    if (!counts[model]) {
      counts[model] = {
        // íƒ€ì„ìŠ¤íƒ¬í”„ ë°°ì—´ë¡œ ëª¨ë“  ìš”ì²­ ì‹œê°„ ì €ì¥
        timestamps: []
      };
    }

    // timestamps ë°°ì—´ì´ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
    if (!counts[model].timestamps) {
      counts[model].timestamps = [];
    }
    
    // í˜„ì¬ íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ê°€
    const now = Date.now();
    counts[model].timestamps.push(now);

    // ëª¨ë¸ì˜ ì œí•œ íƒ€ì…ì— ë”°ë¼ í˜„ì¬ ì‚¬ìš©ëŸ‰ ê³„ì‚°
    if (limits[model]) {
      const limitType = limits[model].type;
      const limitValue = limits[model].value;
      
      // unlimitedê°€ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ì‚¬ìš©ëŸ‰ í™•ì¸
      if (limitType !== 'unlimited') {
        // í˜„ì¬ ì¹´ìš´íŠ¸ ê³„ì‚° - íƒ€ì„ìŠ¤íƒ¬í”„ ë°°ì—´ ê¸°ë°˜
        const currentCount = getCountByType(counts[model].timestamps, limitType);
        
        await chrome.storage.local.set({ usageCounts: counts });
        updateBadge(counts);
        
        // í•œë„ ì„ë°• ì•Œë¦¼ (80% ë„ë‹¬ ì‹œ)
        if (limitValue && currentCount >= limitValue * 0.8) {
          chrome.notifications.create({
            type: 'basic',
            iconUrl: 'icons/icon48.png',
            title: 'ì‚¬ìš©ëŸ‰ ê²½ê³ ',
            message: `${model} ìš”ì²­ì´ ${limitType === 'threeHour' ? '3ì‹œê°„' : limitType === 'daily' ? 'ì¼ì¼' : limitType === 'weekly' ? 'ì£¼ê°„' : 'ì›”ê°„'} í•œë„ì˜ 80%ì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤. (${currentCount}/${limitValue})`
          });
        }
      }
    }
  } catch (error) {
    console.error('[Background] ëª¨ë¸ ì‚¬ìš©ëŸ‰ ì—…ë°ì´íŠ¸ ì—ëŸ¬:', error);
  }
}

// Deep Research init ì‘ë‹µì„ íŒŒì‹±í•˜ê¸° ìœ„í•´ backgroundì—ì„œ ì§ì ‘ fetch
// ê¸°ì¡´ onResponseStarted ë‚´ init ì²˜ë¦¬ ì œê±° í›„ ì•„ë˜ ë¡œì§ìœ¼ë¡œ ëŒ€ì²´
chrome.webRequest.onResponseStarted.addListener(
  (details) => {
    // URLì´ ì¡´ì¬í•˜ëŠ”ì§€ ë¨¼ì € í™•ì¸
    if (!details.url) {
      return;
    }
        
    // ê¸°ì¡´ í—¤ë” ë°©ì‹ë„ ìœ ì§€ (ë‹¤ë¥¸ APIì—ì„œ ì •ë³´ê°€ ìˆì„ ìˆ˜ ìˆìŒ)
    },
    {
        urls: [
            "https://chat.openai.com/backend-api/*",
            "https://chatgpt.com/backend-api/*",
            "https://chat.openai.com/*deep*",
            "https://chat.openai.com/*research*",
            "https://chatgpt.com/*deep*",
            "https://chatgpt.com/*research*"
        ]
    },
    ["responseHeaders"]
);

/**
 * íƒ€ì…ë³„(3ì‹œê°„/ì¼ê°„/ì£¼ê°„/ì›”ê°„) ì¹´ìš´íŠ¸ ê³„ì‚°
 * @param {Array} timestamps - íƒ€ì„ìŠ¤íƒ¬í”„ ë°°ì—´
 * @param {string} type - "threeHour", "daily", "weekly", "monthly" ì¤‘ í•˜ë‚˜
 * @returns {number} í•´ë‹¹ ê¸°ê°„ ë‚´ ì¹´ìš´íŠ¸
 */
function getCountByType(timestamps, type) {
  if (!timestamps || !Array.isArray(timestamps)) return 0;
  
  const now = Date.now();
  let cutoffTime;
  
  switch (type) {
    case 'threeHour':
      cutoffTime = now - (3 * 60 * 60 * 1000); // 3ì‹œê°„
      break;
    case 'daily':
      // ë‹¹ì¼ 00:00 KST ê¸°ì¤€
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      cutoffTime = today.getTime();
      break;
    case 'weekly':
      // ì´ë²ˆ ì£¼ ì›”ìš”ì¼ 00:00 KST ê¸°ì¤€
      const thisMonday = new Date();
      thisMonday.setHours(0, 0, 0, 0);
      // ì›”ìš”ì¼ì´ 0ì´ ì•„ë‹ˆë¼ 1ì´ë¯€ë¡œ ì¼ìš”ì¼ì€ 0, ì›”ìš”ì¼ì€ 1...
      const daysSinceMonday = (thisMonday.getDay() + 6) % 7; // ì›”ìš”ì¼ì„ ê¸°ì¤€ìœ¼ë¡œ ë‚ ì§œ ì¡°ì •
      thisMonday.setDate(thisMonday.getDate() - daysSinceMonday);
      cutoffTime = thisMonday.getTime();
      break;
    case 'monthly':
      // ì´ë²ˆ ë‹¬ 1ì¼ 00:00 KST ê¸°ì¤€
      const thisMonth = new Date();
      thisMonth.setDate(1);
      thisMonth.setHours(0, 0, 0, 0);
      cutoffTime = thisMonth.getTime();
      break;
    default:
      cutoffTime = 0;
  }
  
  // í•´ë‹¹ ê¸°ê°„ ì´í›„ì˜ íƒ€ì„ìŠ¤íƒ¬í”„ë§Œ í•„í„°ë§í•´ì„œ ê°œìˆ˜ ë°˜í™˜
  return timestamps.filter(timestamp => timestamp >= cutoffTime).length;
}

// ë±ƒì§€ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ (ì „ì²´ ì¼ì¼ í•©ê³„)
function updateBadge(counts) {
    let totalDaily = 0;
    for (const model in counts) {
        if (model !== '_lastReset' && counts[model].timestamps) {
            // ê° ëª¨ë¸ì˜ ì¼ê°„ ì¹´ìš´íŠ¸ ê³„ì‚° (íƒ€ì„ìŠ¤íƒ¬í”„ ë°°ì—´ ê¸°ë°˜)
            totalDaily += getCountByType(counts[model].timestamps, 'daily');
        }
    }
    chrome.action.setBadgeText({ text: totalDaily > 0 ? String(totalDaily) : '' });
    chrome.action.setBadgeBackgroundColor({ color: '#0078D4' });
}

// ì •ê¸°ì ì¸ ë°ì´í„° ì •ë¦¬ í•¨ìˆ˜ - ì˜¤ë˜ëœ íƒ€ì„ìŠ¤íƒ¬í”„ ì œê±° (6ê°œì›” ì´ìƒ)
function cleanupOldData() {
    chrome.storage.local.get('usageCounts', data => {
        const counts = data.usageCounts || {};
        const sixMonthsAgo = Date.now() - (180 * 24 * 60 * 60 * 1000); // ì•½ 6ê°œì›”
        
        let changed = false;
        
        // ëª¨ë“  ëª¨ë¸ì— ëŒ€í•´ ì²˜ë¦¬
        for (const model in counts) {
            if (model === '_lastReset') continue;
            
            if (counts[model].timestamps && Array.isArray(counts[model].timestamps)) {
                // 6ê°œì›” ì´ì „ íƒ€ì„ìŠ¤íƒ¬í”„ëŠ” ì œê±°
                const newTimestamps = counts[model].timestamps.filter(ts => ts >= sixMonthsAgo);
                
                if (newTimestamps.length !== counts[model].timestamps.length) {
                    counts[model].timestamps = newTimestamps;
                    changed = true;
                }
            }
        }
        
        // ë³€ê²½ëœ ê²½ìš°ì—ë§Œ ì €ì¥
        if (changed) {
            chrome.storage.local.set({ usageCounts: counts });
        }
    });
}

// ì´ˆê¸° ë±ƒì§€ ì—…ë°ì´íŠ¸
chrome.storage.local.get('usageCounts', data => updateBadge(data.usageCounts || {}));

// í•˜ë£¨ì— í•œ ë²ˆ ì˜¤ë˜ëœ ë°ì´í„° ì •ë¦¬
chrome.alarms.create('cleanupData', { periodInMinutes: 24 * 60 }); // 24ì‹œê°„ë§ˆë‹¤
